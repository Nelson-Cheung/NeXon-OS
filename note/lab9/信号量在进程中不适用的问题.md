**`_running_thread`直接截取栈高20字节得到进程地址的方式存在问题**。因为在进程中，栈的高20位地址是`0xbffff000`，不等于进程PCB的地址。但为什么中断切换时不会出现问题呢？因为时钟中断会从特权级3进入特权级0，CPU会自动加载tss中的esp0栈，此时的esp0栈的高20位地址就是进程的PCB地址，所以不会出现问题。同时，进程切换时需要修改cr3，此时必须在特权级0下。**因此，做出如下改变。**

+ 引入进程后，若当前是用户进程的切换，需要通过系统调用的方式进入内核态，然后再来实现进程切换。若当前是内核线程则不需要。
+ 摒弃使用`esp and 0xfffff000`的方式来得到当前PCB的地址，改用一个变量`currentRunningThread`存储当前PCB。

**通过eax传递系统调用号会出现问题**。如果将系统调用号放入eax后又调用了其他过程，而不是执行`int 0x80`。此时，eax的值很有可能被修改，导致系统调用执行了不是希望出现的过程。**因此，将系统调用的参数传到寄存器后，应当立即执行`int 0x80`。**